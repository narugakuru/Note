---
tags:
  - 数据结构
---

# 一、数据结构概论

## 1. 基本概念

### 1.1. 层次关系

数据类型、数据对象、数据元素、数据项、数据

### 1.2. 数据结构三要素

1. 逻辑结构
	集合，线性，树形，图形结构，决定了算法设计
2. 存储结构
	顺序存储、链式存储、索引存储、散列存储，决定了算法实现
3. 运算操作
	 设计针对逻辑结构，实现针对存储结构

### 1.3. 数据结构

相互之间存在的一种或多种特定关系的数据元素的集合。

### 1.4. 抽象数据类型

可以有多种存储实现，只有逻辑结构（栈，树）

## 2. 算法评价

一般按最坏时间复杂度来算

# 二、线性表

## 1. 线性表的定义和基本操作

### 1.1. 顺序表：顺序表示

随机读写，结点只存储数据，只是逻辑上删除

### 1.2. 链表：链式表示

-   单链表

-   头插法
-   尾插法
-   空表： 头指针为空

-   双链表：快捷查找前驱
-   循环链表

-   空表：头指针=尾指针

-   循环双链表

-   空表：头指针=尾指针

-   静态链表：使用数组实现

# 三、栈，队列和数组

本质上为操作受限的线性表

## 1. 栈

-   先进后出
### 1.1. 顺序栈

-   数组越界时发生栈上溢
-   共享栈:对存取效率无影响，更有效利用空间

### 1.2. 链式栈

-   便于多个栈共享空间和提高其效率，不存在栈满上溢
-   所有操作都在头结点进行。
-   可用头插法建表。

## 2. 队列

-   先进先出，只允许一段插入，另一端删除。
### 2.1. 顺序存储

-   使用数组实现，会发生假溢出，空间利用率低下
-   循环队列，如何区分队空队满？

-   牺牲一个单元来区分队空，队满
-   类型中增设一个count表示元素个数的数据成员
-   类型中增设一个tag来区分。

### 2.2. 链式存储

-   尾插法建队
-   双端队列

## 3. 栈和队列的应用

### 3.1. 栈

-   括号匹配
-   表达式求值
-   递归

### 3.2. 队列

-   树的层次遍历
-   计算机系统，缓冲区，任务队列

## 4. 数组和特殊矩阵

### 4.1. 存储策略

-   对下标分i>j和i<=j讨论，写出转换函数，转换函数见p104
-   行优先
-   列优先

-   对称矩阵：可分为上三角区，主对角线，下三角区
-   三角矩阵

-   上三角矩阵
-   下三角矩阵

-   三对角矩阵：K=2i+j-3
-   稀疏矩阵

-   使用三元组压缩存储
-   代价是失去随机读写性

# 四、串

## 1. 定义和实现

逻辑结构与线性表相似，区别为数据对象为字符集

基本操作通常以子串作为操作对象，如查找，插入和删除一个子串

### 1.1. 存储结构

1.  定长顺序存储
2.  堆分配存储
3.  块链存储

## 2. 串的模式匹配

### 2.1. 暴力匹配n*m

不匹配时，主串和子串同时回退。

### 2.2. KMP算法 n+m

-   由子串《最大相等前后缀》长度得出《匹配值表》PM。例：ababa的匹配值为00123
-   移动位数=已匹配字符数-对应部分的匹配值。MOVE=（J-1)-PM[J-1]
-   主串不回退或滑动，子串不完全回退
-   缺点是，每次匹配失败要找前一个元素的匹配值，这样使用不方便简洁。

### 2.3. KMP算法的进一步改进

-   将PM表右移一位得到next数组，解决使用不方便的缺点，第一个元素的值用-1填充。 MOVE=(J-1)-Next[J]
-   为了使公式更加简洁，将next数组整体+1。MOVE=J-Next[J]
-   Next【J】的含义是，在子串第J个字符失配时，跳到子串的Next【J】位置重新与主串当前位置比较。

### 2.4. 基于KMP的缺陷再优化

-   如aaaab和aaabaaaab匹配时性能较差
-   若Next【J】的字符值和P【J】相等，则执行递归Next【Next【J】】，直到为0或跳转前后字符值不同为止

# 五、树和二叉树

## 1. 树的定义和操作

1.  树时一种递归的数据结构，树的子树也是一颗树
2.  同时树作为一种逻辑结构，也是分层结构

### 1.1. 基本术语

-   深度、高度和层次

-   深度是自顶向下累加，高度是自叶结点向上累加，二者都可表示树的最大层数
-   根表示第一层

-   度

-   结点的最大度是树的度
-   度大于0的结点是分支结点，度为0是叶子结点

-   有序树和无序树：子树从左到右是有次序，不可互换的
-   路径和路径长度：两个结点之间经过的结点序列是路径，路径上边的个数是路径长度

### 1.2. 基本性质

1.  结点数=所有结点度数之和+1。k*Nk+N0+1=N
2.  度为m的树，第i层至多有M^（i-1）个结点
3.  高度为h的m叉树之多有（M^h-1）/（m-1）个结点
4.  n个结点的m叉树最小高度是logm（n(m-1)+1)向上取整

### 1.3. 二叉树的定义和操作，特殊二叉树

1.  满二叉树：每一层都满编h=log2（n+1）
2.  完全二叉树：从左到右，依次存储，h=log2（n+1)向上取整
3.  排序二叉树：根结点大于左结点，小于右结点

### 1.4. 二叉树性质

-   编号i的结点，左孩子为2i，右孩子为2i-1
-   父节点为i/2向下取整。
-   N0=N2+1
-   N=N0+N1+N2
-   N=2N2+N1+1

### 1.5. 和度为2的树的主要区别

1.  二叉树的度恒为2，一个空二叉树度依旧为2
2.  树的结点的左右孩子是相对的，在只有一个孩子的不区分左右孩子，而二叉树严格区分。

## 2. 二叉树遍历和线索二叉树

### 2.1. 二叉树的遍历

-   先序遍历：先序和中序思想类似，先序先访问结点后入栈再指向孩子结点
-   中序遍历：中序先入栈再指向孩子结点，直到某一结点无孩子结点时才开始访问。
-   后序遍历: 将根结点入栈，然后沿左子树一直向下，将路径上的结点都入栈，直到无左子树，在访问右子树，重复……，直到找到叶子结点，栈顶出栈。**可用于查找祖先结点。**
-   层次遍历：借助队列实现，先将根结点入队，然后每将一个结点出队时，就把它的结点都入队。
-   能用递归尽量递归，递归算法要借助递归栈，而非递归算法要借助结点指针栈。
-   **由遍历构造二叉树**

-   先序和中序
-   后序和中序
-   层次和中序
-   先序和后序无法构造

### 2.2. 线索二叉树

-   原理：有n个结点的二叉树，必有n+1个空指针，可用空指针来指向直接前驱和直接后继
-   构造

-   线索二叉树的构造是建立在先序，中序，后序序列其中一个的基础上的。
-   左指针为空，则使其指向前驱结点；右指针为空，则使其指向后继结点

-   **实现**

-   使用tag来标记指针是指向前驱后继还是左右孩子
-   后继线索二叉树较为复杂
-   可使用带标致域的三叉链表存储

## 3. 树和森林

### 3.1. 森林的存储结构

-   双亲表示法

-   用数组存储结点，并为每个结点设一个伪指针，指向它的双亲
-   优点是求祖先结点非常简单
-   缺点是求孩子结点需要遍历整个结构

-   孩子表示法

-   每个结点的孩子结点用单链表链接形成一个线性结构，结点本身用数组存储（类似邻接表）
-   优点是找孩子结点快速简单
-   缺点是找父节点需要遍历整个数据结构

-   孩子兄弟表示法

-   用二叉链表作为存储结构，转化为二叉树时非常方便
-   每个结点包含：结点数据，左指针指向结点第一个孩子的指针，右指针指向结点下一个兄弟结点的指针

### 3.2. 树和二叉树的转换

将树用孩子兄弟表示法表示即可

### 3.3. 树和森林的遍历及其对应关系

-   树

-   先根遍历
-   后根遍历（也叫中根遍历）

-   森林

-   先序遍历
-   中序遍历

-   二叉树

-   先序遍历
-   中序遍历

## 4. 树和二叉树的应用

### 4.1. 哈夫曼树

-   哈夫曼编码用于求最短带权路径长度：所有叶子结点的带权路径长度之和称为树的带权路径长度
-   构造方法：每次选择两个最小权值的结点生成一个新结点，直到所有结点合成一颗树
-   哈夫曼编码是**前缀编码**，即没有一个前缀是另一个编码的前缀

### 4.2. 并查集操作

-   每个元素初始化为一个单元素的子集合
-   当两个集合互不相交时，合并两个集合：将一个集合的根结点，指向另一个元素的根结点即可
-   查找单个元素所在子集合，返回子集合的根结点

# 六、图

## 1. 基本定义

## 2. 图的存储和操作

## 3. 图的遍历

## 4. 图的应用

# 七、查找

## 1. 基本概念

## 2. 顺序查找和折半查找

## 3. 树型查找

## 4. B树和B+树

## 5. 散列表

# 八、排序

## 1. 基本概念

## 2. 插入排序

## 3. 交换排序

## 4. 选择排序

## 5. 归并排序和基数排序

## 6. 内部排序算法的分析和比较

## 7. 外部排序