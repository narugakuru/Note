# UML概述  作者——小岚岚

> **UML组成：**元素，图，关系

**其中元素有：**类，接口，用例，组件，节点，消息，连接，状态，事件，活动等。

![image-20220106202047740](https://gitee.com/diaborosu/raisei-pic-md/raw/master/image/image-20220106202047740.png)

### UML 的三个主要的特性。

1） UML 是一种可视化语言；
2） UML 用于建模；
3） UML 是一种统一的标准。

### UML 是一种方法论吗？

UML 并不是 OOA/D，也不是方法论，它只是图形表示法**可视化语言**，**是一种描述模型的标准语言**， 虽然渗透了许多方法论的基础概念，但是却没有在标准中给出完整的方法指南。



# 用例和用例图

> 用例是什么?
>
> 用例是对一组动作的描述，系统执行这些动作将对用例的参与者产生可以看到的影响和结果，用来描述参与者可以感受到的系统服务或功能。

### 一张用例图所包含的的元素

1. **参与者(Actor)——**与应用程序或系统进行交互的用户、组织或外部系统。**用一个小人表示**。
2. **用例(Use Case)——**用例就是外部可见的系统功能，对系统提供的服务进行描述。**用椭圆表示**。
3. **系统边界(Subsystem)——**用来展示系统的一部分功能，这部分功能联系紧密。
4. **关联(Association)——**它表示参与者和用例的关系。



### 用例图所包含的的关系

　　用例图中涉及的关系有：**关联、泛化、包含、扩展、（依赖）。**

![image-20220106153423535](https://gitee.com/diaborosu/raisei-pic-md/raw/master/image/image-20220106153423535.png)

 　**a. 关联(Association)**

　　表示参与者与用例之间的通信，任何一方都可发送或接受消息。

　　【箭头指向】：无箭头，将参与者与用例相连接，指向消息接收方

　　![img](https://images0.cnblogs.com/blog2015/775886/201506/201545377481898.png)

　　**b. 泛化(Inheritance)**

　　就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。在实际应用中很少使用泛化关系，子用例中的特殊行为都可以作为父用例中的备选流存在。

　　【箭头指向】：指向父用例

![img](https://images0.cnblogs.com/blog2015/775886/201506/201746081706263.png)

　　**c. 包含(Include)**

　　包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。包含关系对典型的应用就是复用，也就是定义中说的情景。但是有时当某用例的事件流过于复杂时，为了简化用例的描述，我们也可以把某一段事件流抽象成为一个被包含的用例；相反，用例划分太细时，也可以抽象出一个基用例，来包含这些细颗粒的用例。这种情况类似于在过程设计语言中，将程序的某一段算法封装成一个子过程，然后再从主程序中调用这一子过程。

　　例如：业务中，总是存在着维护某某信息的功能，如果将它作为一个用例，那添加、修改以及删除都要在用例详述中描述，过于复杂；如果分成添加用例、修改用例和删除用例，则划分太细。这时包含关系可以用来理清关系。

　　【箭头指向】：指向分解出来的功能用例

![img](https://images0.cnblogs.com/blog2015/775886/201506/201813400459106.png)

　　**d. 扩展(Extend)**

　　扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。将基用例中一段相对独立并且可选的动作，用扩展（Extension）用例加以封装，再让它从基用例中声明的扩展点（Extension Point）上进行扩展，从而使基用例行为更简练和目标更集中。扩展用例为基用例添加新的行为。扩展用例可以访问基用例的属性，因此它能根据基用例中扩展点的当前状态来判断是否执行自己。但是扩展用例对基用例不可见。

对于一个扩展用例，可以在基用例上有几个扩展点。

　　【箭头指向】：指向基础用例

![img](https://images0.cnblogs.com/blog2015/775886/201506/201822539989736.png)

　　**e. 依赖(Dependency)**

　　以上4种关系，是UML定义的标准关系。但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示，表示源用例依赖于目标用例。

　　【箭头指向】：指向被依赖项

![img](https://images0.cnblogs.com/blog2015/775886/201506/201825317797833.png)

　**5. 项目(Artifact)**

　　用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，VS2010中引入了“项目”这样一个元素，以便让开发人员能够在用例图中链接一个普通文档。

　　用依赖关系把某个用例依赖到项目上：

![img](https://images0.cnblogs.com/blog2015/775886/201506/201834316387902.png)

　　然后把项目->属性的Hyperlink设置到你的文档上；

　　这样当你在用例图上双击项目时，就会打开相关联的文档。

　　**6. 注释(Comment)**

![img](https://images0.cnblogs.com/blog2015/775886/201506/201837532489411.png)

**包含(include)、扩展(extend)、泛化(Inheritance) 的区别：**

 

- 条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；
- 直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。
- 对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。
- 对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；



1. 泛化侧重表示子用例间的互斥性；
2. 包含侧重表示被包含用例对Actor提供服务的间接性；
3. 扩展侧重表示扩展用例的触发不定性；

　　另外一点需要提及的是：泛化中的子用例和扩展中的扩展用例均可以作为基本用例事件的备选择流而存在。

 



# 类图和对象图

> 类是一组具有相同属性，操作，关系和语义的对象的抽象。主要包括：名称、属性部分、操作部分。
>
> 属性和操作部分，+表示pulic，-表示private，#表示protected，~表示包内公有default。

### 类的关系

![image-20220106162934004](https://gitee.com/diaborosu/raisei-pic-md/raw/master/image/image-20220106162934004.png)

- **关联关系(Association):**

  通常关联关系用来实现连接有关联的对象所对应的类，**即将一个类的对象作为另一个类的属性。**还有就是关联关系可以是单向的也可以是双向的。双向的符号是没有方向标的，只是一条直线。

- **聚合关系(Aggregation):**

  表示整体与部分的关系。**成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。**聚合关系有一个特点，那就是可替换。

- **组合关系(Composition)：**

  表示整体与部分的关系。但是与聚合不同此关系是**整体与部分的生命周期相同。**即如果整体对象销毁了部分也会被销毁。

  > 关联，聚合，组合关系都属于依赖关系的

- **依赖关系(Dependency)：**

  是一个使用关系，**在一个类中通过另外一个类来调用其方法**的表示。特定事物的改变有可能会影响到使用该事物的其他事物。

- **泛化关系(Generalization)：**

  是一种继承关系，子用例将继承基用例的所有属性、行为，关系和通信关系，也就是说在任何使用基用例的地方都可以用子用例来代替。

- **实现关系(Realization):**

  **类实现了接口。**当多个类有类似的行为方式的时候我们通常会适用接口。

### 多重性的联系

![image-20220106163039210](https://gitee.com/diaborosu/raisei-pic-md/raw/master/image/image-20220106163039210.png)





**分析一个类图**

![image-20220106163124179](https://gitee.com/diaborosu/raisei-pic-md/raw/master/image/image-20220106163124179.png)

**分析：**

>用户通过注册界面(RegisterForm)输入个人信息，
>用户点击“注册”按钮后将输入的信息通过一个封装用户输入数据的对象(UserDTO)传递给操作数据库的数据访问类(DAO)，
>为了提高系统的扩展性，针对不同的数据库可能需要提供不同的数据访问类，因此提供了数据访问类接口，
>如IUserDAO，每一个具体数据访问类都是某一个数据访问类接口的实现类，
>如OracleUserDAO就是一个专门用于访问Oracle数据库的数据访问类。

### 类的种类

#### **边界类**

**（1）用来描述什么问题？**
**边界类用于描述外部参与者与系统之间的交互，**是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。这种交互包括**转换事件，并记录系统表示方式（例如接口）中的变更。**
**（2）可以带来什么好处？**
识别边界类可以帮助开发人员识别出用户对界面的需求。
**（3）如何理解边界类**
边界类位于系统与外界的交界处，窗体、报表、以及表示通讯协议的类、**直接与外部设备交互的类、直接与外部系统交互的类等都是边界类**，通过用例图可以确定需要的边界类，每个Actor/Use Case对至少要一个边界类。



#### **实体类**

**定义**

实体类是用于对必须存储的信息和相关行为建模的类。实体对象（实体类的实例）用于保存和更新一些现象的有关信息，例如：事件、人员或者一些现实生活中的对象。

实体类主要是**作为数据管理和业务逻辑处理层面上存在的类别**

实体类保存要放进持久存储体的信息。持久存储体就是数据库、文件等可以永久存储数据的介质。

实体类可以通过事件流和交互图发现。通常每个实体类在数据库中有相应的表，实体类中的属性对应数据库表中的字段。

**作用**

实体类的**主要职责是存储和管理系统内部的信息，它也可以有行为**，甚至很复杂的行为，但这些行为必须与它所代表的实体对象密切相关。



#### **控制类**

**（1）用来描述什么问题？**
控制类**用于描述一个用例所具有的事件流控制行为，控制一个用例中的事件顺序**
**（2）如何理解控制类？**
**控制类是控制其他类工作的类。**每个用例通常有一个控制类，控制用例中的事件顺序，控制类也可以在多个用例间共用。其他类并不向控制类发送很多消息，而是由控制类发出很多消息。



**应用举例**
例如：考试系统中当学生在考试时 ,学生与试卷交互， 那么学生和**试卷都是实体类**,而考试时间,规则,分数都是边界类，当考试完了将试卷提交给试卷保管者,则**试卷则成了边界类。**



# 顺序图和通信图

>也叫时序图和协作图

### 顺序图（基于对象交互时的交互顺序）

**1.顺序图概念**
      用于捕获系统运行中对象之间有顺序的交互，强调的是消息交互的时间顺序。顺序图由生命线和消息组成：

>顺序图 = 生命线 + 消息

**2.组成**

> 顺序图包含：角色，对象，消息，生命线，激活

 **1）活动者角色(Actor)和对象(Object)**

活动者和对象按照从左到右的顺序排列。一般最多两个活动者，他们分列两端。启动这个用例的活动者往往排在最左边；接收消息的活动者则排在最右端； 对象从左到右按照重要性排列或按照消息先后顺序排列。

 对象的三种命名方式如下：

**2）消息（Message）**

面向对象方法中，消息是对象间交互信息的主要方式。 结构化程序设计中，模块间传递信息的方式主要是过程（或函数）调用。 对象A向对象B发送消息，可以简单地理解为对象A调用对象B的一个操作（operation）。

 顺序图中，尽力保持消息的顺序是从左到右排列的。 一个顺序图的消息流开始于左上方，消息2的位置比消息1低，这意味着消息2的顺序比消息1要迟。因为西方的阅读习惯是从左到右。 顺序图中消息编号可显示，也可不显示。协作图中必须显示。

 **UML三种消息： 调用（Procedure Call） 异步（Asynchronous） 返回（Return）** 

**Rose扩充： 阻止（Balking） 超时（Time-out）**

-   调用： 发送者把消息发送后，等待直到接收者返回控制，可以表示同步； 实心箭头符号
-   异步： 消息发送后，发送者继续操作，不等待，常用于并发
- 返回：表示消息的返回。消息上方放置返回值 同步消息的返回可以画出（如果想明确表达返回值），也可以不画出，直接隐含。 异步消息可以有返回，也可以没有。（可以响应异步消息，也可以不响应该异步消息。） 如果顺序图上显示有编号，则返回消息的编号和当初发送消息的编号完全一样。 用虚线箭头表示，和依赖关系不要混淆

- 自调用（Self Call）：某对象自己调用自己的操作 UML标记 （嵌套的矩形条）     Rose标记


**3）生命线( Life-lin e)**

每个对象都有自己的生命线，用来表示在该用例中一个对象在一段时间内的存在 垂直的虚线 如果对象生命期结束，则用注销符号表示 对象默认的位置在图顶部，表示对象在交互之前已经存在 如果是在交互过程中由另外的对象所创建，则位于图的中间某处。

**4）激活器或控制焦点(Focus of control)**

激活期(activation)/控制焦点（focus of control） 对象在一段时间内获得了焦点，也称激活期 对象执行某个动作的时期 空心矩形条 激活期的长短意味着对象执行某个动作的时间有多长，可以通过约束{10ms}来限制执行时间的长短。



**3.建立顺序图的步骤**

1. 确定交互的范围；
2. 识别参与交互的对象和活动者；

3. 设置对象生命线开始和结束；
4. 设置消息；

5. 细化消息；

 

### 通信图（基于对象交互的行为建模）

**1.通信概念**
      强调对象之间在交互作用时的关联。

 通信图的消息发生顺序用图中的消息编号的方法来表示。表达式为：

> 通信图 = 交互的参与者 + 通信链 + 消息

**2.通信图的表示方法**
1）交互的参与者

 交互的参与者用一个对象符号来表示，在矩形框中放置交互的参与者，显示交互的参与者的名称和它所属的类：参与者名：类名

2）链接

   链接表示两个对象间的连接路径，沿着这条路径，消息可以流动。UML用直线表示链接、

3）消息

   消息用依附于链接的带标记的箭头和带顺序号的消息表达式表示。



### 顺序图和通信图有什么区别？

**顺序图和通信图可互相转化**，本质上只是同一种信息的不同展现形式。

**UML有两种表达形式的交互图：顺序图和通信图，均可以完整的表达对象之间信息的交互过程，区别在于关注点不同：**

- 顺序图：按时间顺序对消息的交互过程建模，展示的是按时间顺序发生的消息传送。
- 通信图：按对象关联对消息的交互过程建模，强调消息交互传递中对象之间的关联。



# 状态机图和活动图

### 用处概述

- **状态机图**：展示状态与状态转换的图。
- **状态**：是状态机的重要组成部分，它描述了状态机所在的对象动态行为的执行所产生的结果。
  - **状态图**(Statechart Diagram)，"状态"顾名思义,用来表示对象的状态变化。它描述了一个特定对象的所有可能状态以及由于各种事件的发生引起的状态之间的转换。
  - **活动图**（activity diagram）也称动态图，其本质就是流程图，它支持并行活动，用于展现参与行为的类的活动或动作。

联系：活动图和状态图都可用来可视化状态机。

### 状态机图

> 状态图包括：状态，事件，组合状态。

**１、状态。**

状态名字，进入动作，退出动作，状态中发生的活动（状态内活动，状态向外发送的活动）。

**２、事件**

使状态发生变化的某时刻发生的动作，或者活动。状态发生转化的条件。

**３、组合状态**

一个状态内部包含其他状态，成为组合状态，内部被包含的状态被成为子状态。如果被包含的是一个子状态图，那么该子状态图必须有自己的起始状态和终止状态。

**实例演示**

![image-20220106170512579](https://gitee.com/diaborosu/raisei-pic-md/raw/master/image/image-20220106170512579.png)

### 活动图

1. **活动状态**

   表示在工作流程中执行某个活动或步骤。

2. **转移**

   表示各种活动状态的先后顺序。这种转移可称为完成转移。它不同于一般的转移，因为它不需要明显的触发器事件，而是通过完成活动(用活动状态表示)来触发。

3. **决策**

   为其定义了一组警戒条件。这些警戒条件决定在活动完成后将执行一组备选转移中的哪一个转移。您也可以使用判定图标来表示线程重新合并的位置。决策和警戒条件使您能够显示业务用例的工作流程中的备选线程。

4. **同步示意条**

   用于显示平行分支流。同步示意条使您能够显示业务用例的工作流程中的并行线程。

5. **泳道**

   对活动进行分组。怎么分组——每一个区域都代表特定的类，或者是人，或者是部门责任区。在含有泳道的活动图中，清晰的表明了每个活动的执行对象。在活动图中每个活动只可以属于一个泳道。

6. **对象流**

   活动图中可以将活动涉及到得对象通过依赖将其连接在状态或者活动上。对象用矩形框表示。

**实例演示**

![image-20220106170157866](https://gitee.com/diaborosu/raisei-pic-md/raw/master/image/image-20220106170157866.png)





### 状态机图和活动图有什么区别？

状态图是描述某一对象的**状态转化**的，它主要是展示的是对象的状态。描述的是一个对象的事情。从状态图中我们可以看出，对象在接受了事件刺激后，会做出什么样的反应。

活动图是描述系统在执行某一用例时的**具体步骤**的，它主要表现的是系统的动作，描述的是整个系统的事情。



# 构件图和部署图

### 构件图

 构件图（Component diagram）是面向对象系统从物理方面建模时用到的图之一，显示一组构件之间的组织和依赖关系。使用构件图的思想是复用。就像是我们盖房子，当房子的大体框架建好之后，剩下的门和窗户家具之类的直接拿来安装上即可，不需要再从新制作，直接拿来复用的思想。这些门和窗户就相当于一个个的构件。

​     **1、构件（Component）：**

是系统中遵从同一组接口且提供其实现的物理的、可替换的部分。每个构件能实现一定的功能为其他构件提供使用接口、方便软件的复用。例如对象库、可执行体、COM+、企业级Java Bean。

​        ![img](https://gitee.com/diaborosu/raisei-pic-md/raw/master/image/669808-20181108100506353-2098517980.png)

​      **2、构件类型：**

  源代码构件：源代码文件

  二进制构件：目标码文件，静态链接库、动态链接库

  可执行构件：可执行程序

  数据文件或文档

​     **3、构件图的组成：**

 构件图中包括构件、接口和四种关系，还可以包含注释和约束，以及一些包或者子系统。



**要想构造出良好的构件图必须满足的几个要求：**

​    1、侧重于描述系统的一个层面而不是全局

​    2、要包含对于理解这一方面哪些是必要的模型元素，只抓主体而不是次要的

​    3、图形不能过于简化，以至于读者不会产生误解

​    4、为构件图要取一个能表明意图的名称

​    5、空间摆放上要合理组织元素，使得语义上接近的事物的物理位置比较接近

​    6、谨慎采用构造型化元素，为你的项目或者组织选择尽量少用的通用图标，使得他们保持一致

### 部署图

部署图（Deployment Diagram）也叫做实施图，描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。可以了解**软件和硬件的物理关系以及处理节点的组件分布情况**，传达了构成应用程序的硬件和软件元素的配置和部署方式。一个部署图描述了一个运行时的硬件节点，以及在这些节点上运行的软件组件的静态视图。

   **1、节点（Node）:**

节点是一个物理元素，在运行时存在，代表一个可计算的资源，通常占用一些内存，可以是硬件也可以是运行其上的软件系统，比如64主机、Windows server 2008操作系统、防火墙等。



### 构件图和部署图有什么区别？

   构件图主要目标是集中在描述系统中有哪些构件，以及构件的组成和之间的依赖关系。部署图描述的是靠节点完成，描述软件是如何在硬件上映射的以及网络的拓扑结构。

   在构件图中关系可以是四种，即关联、依赖、实现和泛化。而在部署图中各节点之间的关系只有关联和依赖。  



# 杂乱简答题

**软件工程方法的提出目的应该是最终解决软件的 什么问题？**

答：软件生产工程化

软件工程开发的**可行性研究**是决定软件项目（ 是否持续开发 ）的关键。软件**需求分析**应确定的是用户对软件的（ 功能需求和非功能需求 ）。**耦合**是软件中各模块间相互联系的一种度量,耦合的强弱取决于模块间的复杂程度。耦合的若干种类中,耦合度最高的是（内容耦合 ）。

由事务型数据流图映射为软件结构的设计首先应设计一个（ 总控模块 ），它有两个功能，接收事务数据，另一个是根据事务类型调度相应的处理模块。



**什么是高内聚度？**

答：高内聚度是对一个类中的各个职责之间相关程度和集中程度的度量。一个具有高度相关职责的类并且这个类所能完成的工作量不是特别巨大，那么它就具有高内聚度。包括两个意思：不要给一个类分派太多的职责，在履行职责时尽量将部分职责分派给有能力完成的其它类去完成。不相关的职责不要分派给同一个类。

 

**UML提供一系列的图支持面向对象的分析与设计,其中类图给出系统的静态设计视图：**

**用例图**对系统的行为进行组织和建模是非常重要的;**序列图（顺序）**和**协作图（通信**）都是描述系统动态视图的交互图,其中**序列图（顺序）**描述了以时间顺序组织的对象之间的交互活动,**协作图（通信**）强调收发消息的对象的组织结构。



**UML中的交互图有两种，分别是顺序图和协作图，请分析一下两者之间的主要差别和各自的优缺点。掌握利用两种图进行的设计的方法。**

答：协作图可视化地表示了对象之间随时间发生的交互，它除了展示对象之间的关联，还显示出对象之间的消息传递。与顺序图一样，协作图也展示对象之间的交互关系。顺序图强调的是交互的时间顺序，而协作图强调的是交互的语境和参与交互的对象的整体组织。顺序图按照时间顺序布图，而协作图按照空间组织布图。顺序图可以清晰地表示消息之间的顺序和时间关系，但需要较多的水平方向的空间。协作图在增加对象时比较容易，而且分支也比较少，但如果消息比较多时难以表示消息之间的顺序。



**从哪些方面验证软件需求的正确性？**

答：（1）**一致性**，即所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。2）**完整性**，需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。3）**现实性，**指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。4）**有效性**，必须证明需求是正确有效的，确实能解决用户面对的问题。



**请将下述有关模块独立性的各种模块内聚，按其内聚度（强度）从高到低排列起来。**

① 巧合内聚     ② 时间内聚     ③ 功能内聚    ④ 通信内聚 ⑤ 逻辑内聚   ⑥ 信息内聚   ⑦ 过程内聚

答案：③、⑥、④、⑦、②、⑤、①



**什么是用例，用例模型，如何描述用例？**

答：用例是一个描述性的文档，用来描述一个参与者使用系统完成某个业务过程时的事件发生顺序。用例描述的是系统使用过程，它描述了系统的功能需求。用例不描述系统内部如何工作，而是定义系统的责任，说明系统必须做什么。用例模型是需求工作的一个重要的制品。



**简述如何在实际工作中发现类。**

答：在与客户的交谈中，要注意客户用来描述**业务实体**的名词术语。这些名词可作为领域模型中的类。

还要注意你听到的动词，因为这些动词可能会构成这些类中的操作。当得到一组类的核心列表后，应当向客户询问在业务过程中每个类的作用。他们的回答将告诉你这些类的职责。



**简述实现继承和接口继承的区别？我们应该尽量使用哪一种？**

答： 类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和表示的共享机制。然而，接口继承描述了一个对象什么时候能被用来替代另一个对象。

类继承是派生中的类将继承父类的所有属性和方法，并且可以在派生类里添加自己的属性和方法，而接口继承则是在接口里只定义接口的方法，没有属性，并且方法不能实现，只有在派生他的类才实现该方法。类继承是编译的时候新建对象，而接口实例是在运行时刻创建对象。我们应该尽量使用接口继承，类继承会产生类爆炸现象