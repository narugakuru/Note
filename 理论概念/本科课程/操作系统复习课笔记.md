# 题型

## 选择	10*2'

## 判断	10*2'

## 简答	4*5'

## 计算编程	4*10'



> 以下为重要知识点，可能出现在选择、填空判断

# 一	操作系统概述

## 定义

​	**操作系统**	是一组能有效地组织和管理计算机硬件和软件资源
​					   合理地对各类作业进行调度
​					   以及方便用户使用的程序的集合。

## 目标

> <font color='red'>方便性和有效性最重要</font>

- 方便性：

    ​	可以用高级语言或OS命令操作计算机，方便用户使用

- 有效性：

    ​	提高系统资源利用率：充分利用系统资源

    ​	提高系统吞吐量：加速程序运行，缩短程序的运行周期

- 可扩充性：

    ​	方便增添新的功能和模块

    ​	对原有的功能和模块进行修改

- 开放性：

    ​	遵循开发标准，提高兼容性



## 作用

1. 用户与计算机硬件系统的接口

    > 用户使用计算机的三种方式：
    >
    > - 命令方式
    > - 系统调用方式
    > - 图标—窗口模式

2. 计算机系统资源的管理者

    > 四类软硬件资源：
    >
    > ​		处理机、存储器、I/O设备、文件(数据和程序)

3. 对计算机资源的抽象

    > 隐藏了I/O设备的具体细节



## 发展过程

### 未配置操纵系统的计算机系统

1. 人工操作



2. 脱机I/O



### 单道批处理系统

1. 过程：
    		将 一批作业以脱机方式输入到磁带上，在系统配置的监督程序的控制下，使各作业能连续的一个接一个被调入内存进行处理。
    ![image-20211223211537032](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211223211544.png)
2. 特点：
    - 自动性 ：无需人工干预
    - 顺序性 ：作业先进先出
    - 单道性 ：在内存中仅有一道程序

3. 缺点：
    - CPU 大量时间在空闲等待 I/O 完成
    - 系统中的资源得不到充分的利用
4. 解决方法：
    - 多道程序设计技术



### 多道批处理

1. 多道程序设计技术基本概念：
    		在内存中同时存放多个作业，并使它们共享系统的资源且同时运行的技术。

2. 过程：

    - 用户所提交的作业都先存放在 外存上 并排成一个队列 ，由作业调度程序按一定的算法从队列中，选择若干个作业调入内存
    - 在内存中的多道程序，它们在管理程序的控制下 相互 穿插 地运行。

    ![image-20211223211937377](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211223211937.png)

3. 特点：

    - 多道性
    - 宏观上并行
    - 微观上串行

4. 优点：

    - 资源利用率高
    - 系统吞吐量大

5. 缺点：

    - 无交互能力
    - 平均周转时间长

6. 多道批处理系统需要解决的问题：
    - 处理机争用问题
    - 内存分配和保护问题
    - I/O设备分配问题
    - 文件的组织和管理问题
    - 作业管理问题
    - 用户与系统的接口问题



### 分时操作系统

> 用户还需要人机交互，共享主机——通过分时技术解决

1. 概念：将CPU时间花分成时间片，每个时间片轮流执行用户程序

2. 特点：
    - 多路性
    - 独立性
    - 及时性
    - 交互性



### 实时操作系统

> 引入：要求及时处理的场合

1. 概念：实时系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理
2. 特征：
    - 高响应性（及时性）
    - 高可靠性、高安全性

3. 实时任务类型
    - 根据周期性
        - 周期性实时任务
        - 非周期性实时任务
    - 根据对截止时间的要求
        - 硬实时任务
        - 软实时任务
4. 实时系统类型
    - 实时控制系统：例如工业控制；导弹发射；飞机飞行；汽车自动驾驶
    - 实时信息系统：例如联网订票系统；事务查询系统

![image-20211223212640068](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211223212640.png)



### 微机操作系统

- 单用户单任务操作系统
    - CP/M，MS-DOS
- 单用户多任务操作系统
    - Windows
- 多用户多任务操作系统
    - Unix





## 基本特性（特征）

> 并发和共享是多用户（多任务）操作系统的两个<font color='red'>最基本的特征</font>。
>
> 他们是互为存在的条件：
>
> - 一方面，资源**共享 ** <u>是以</u>  进程的  **并发**  执行**为条件**的，若系统不允许并发执行也就不存在资源共享问题
> - 另一方面，若系统**不能对资源共享**实施<u>有效管理</u>，以协调好诸进程对共享资源的访问，也必然会**影响到进程间并发执行**的程度，甚至无法并发执行

### 并发

- 并行性：

    - 强调的是瞬间时的共同发生
    - 指两个或多个时间在同一**时刻**发生

- 并发性：

    - 指两个或多个事件在同一**时间间隔**内发生

    

### 共享

概念：系统中的资源可供多个并发的进程共同使用

共享方式：

- 互斥共享方式：
    - 一段时间只允许一个进程访问该资源
- 同时共享方式：
    - 允许在一段时间内由多个进程同时对他们进行访问
    - 内存空间，磁盘空间

### 虚拟

概念：通过某种技术将一个物理实体映射为若干个对应的逻辑实体

> 慢的—>快的、容量小—>容量大的、不能共享的—>能共享的

虚拟技术：

- 时分复用技术：为每道程序建立至少一个进程，让多道程序并发执行
    - 提高资源利用率
    - 虚拟处理机、虚拟设备
- 空分复用技术：将一个频率范围较宽的信道划分为多个频率范围较窄的信道
    - 提高信道（空间）利用率
    - 虚拟存储器、虚拟磁盘

### 

### 异步

- 系统中并发执行的多道程序以不可预知的速度向前推进
- 难以重现系统在某一时刻的状态

## 主要功能

> 操作系统的功能有：
> 			**处理机管理、存储器管理、设备管理、文件系统管理**
> 			*用户接口*、 面向系统安全、网络和多媒体等新功能

### 处理机管理

> <font color='red'>处理机是最重要的资源</font>
>
> 多道环境下 处理机的运行及分配都是**以 进程 为单位** 
>
> 因此处理机管理可归结为 进程管理 。

1. **进程控制**

    > 主要功能为如下三个：

- 创建进程，分配资源

- 运行结束，撤销回收进程
- 控制进程在运行过程中的状态转换



2. **进程同步**

- 主要任务：为多个进程的运行进行协调
- 协调方法
    - 进程互斥方式
    - 进程同步方式——信号量机制



3. **进程通信**

- 主要任务：实现相互合作进程之间的信息交换

- 直接通信方式：
    - 源程序将消息挂到目标进程消息队列
    - 目标进程从消息队列取出信息



4. **调度**

- 作业调度	基本任务：
    - 从后备队列中 按照算法 选择*若干*作业 分配资源
    - 调入内存 创建进程 插入进程就绪队列
- 进程调度	基本任务：
    - 从进程就绪队列 按照算法 选出*一个*进程 分配处理机
    - 设置运行现场 投入运行



### 存储器管理

> <font color='red'>存储器是第二重要资源</font>

1. **内存分配**

- 主要任务：
    - 为每道程序分配内存
    - 提高存储器利用率，较少内存碎片
    - 允许运行程序申请附加内存
- 分配方式
    - 静态：
        - 作业内存空间是作业装入时确定的
        - 运行时**不允许**申请附加内存  和  进行移动
    - 动态：
        - 作业内存空间是作业装入时确定的
        - 运行时**允许**申请附加内存  和  进行移动



2. **内存保护**

- 主要任务：
    - 确定程序在自己内存运行，互不干扰
    - 不允许用户程序访问操作系用程序和数据
    - 不允许用户程序转移去非共享程序
- 保护机制：
    - 设置两个界限寄存器
    - 存在放在执行程序上下界，防止越界



3. **地址映射**

- 主要任务：
    - 实现**地址空间中的逻辑地址**  转换为   **内存空间中的物理地址**



4. **内存扩容：**

- 主要任务：借助虚拟存储技术，从逻辑上扩容内存容量，实现“虚拟存储器”
- 主要功能：
    - 请求调入功能
        - 装入部分程序即可运行
        - 缺少所需程序 发出请求 进行调入内存
    - 置换功能
        - 无内存空间装入所需程序 调出不用程序至外存
        - 腾出空间 将所需调入内存
- 好处：
    - 满足用户需要，改善系统性能



### 设备管理

> 设备是计算机中最庞大琐碎的部分

1. **缓冲管理**

- 主要任务：
    - 对缓冲区进行管理
- 常见缓冲区机制：
    - 单缓冲机制
    - 双缓冲机制
    - 公用缓冲池机制
- 缓冲区好处：
    - 缓和CPU和I/O设备速度不匹配矛盾
    - 提高CPU利用率，提高系统吞吐量
    - 改善系统性能



2. **设备分配**

- 主要任务：
    - 根据用户进程I/O请求，根据现有情况和策略，分配所需设备
- 常用数据结构：
    - 设备控制表、控制器控制表



3. **设备处理**

> 设备处理程序又称为设备驱动程序

- 主要任务：
    - 实现CPU和设备控制器之间的通信
- 处理过程：
    - 检查是否空闲和读取传递参数
    - CPU向设备控制器发出I/O请求，进行操作
    - 或者时中断请求，进行响应处理



4. **设备独立性和虚拟设备**



### 文件管理

> 概述：对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性
>
> 目标：方便、安全

1. **文件存储空间的管理**

- 主要任务：
    - 为文件分配外存
    - 设置响应数据结构，记录文件存储空间使用情况
    - 对存储空间分配和回收

- 好处：
    - 提高外存利用率
    - 提高文件系统的存、取速度



2. **目录管理**

- 主要任务：
    - 为文件建立目录项
    - 进行对目录项的管理
    - 实现文件共享
- 好处：
    - 查询速度快
    - 提高文件检索速度



3. **文件的读/写管理**

- 概述：

    - 从外存中读取数据
    - 将数据写入外存
    - 设置读/写指针，操作完成后方便下一次操作

    

4. **文件保护**

- 主要任务：
    - 防止无权用户存取文件
    - 防止冒名顶替文件
    - 防止不正确使用文件



### 用户接口

1. **用户接口**

> 用户通过以下命令接口，发出命令，控制作业运行

- 命令接口：

    > 命令接口又可以分为以下三种

    - 联机用户接口
    - 脱机用户接口
    - 图形用户接口

    

2. **程序接口**

- 系统调用





# 二	进程

>作业 ：作业是用于人机之间交互的一个概念
>			 指用户提交给系统的一个计算任务
>程序 ：是作业的组成部分
>进程 ：对应一个程序的一次动态执行过程
>线程：进程中的一 个实体

## 进程的定义

>进程是程序的一次动态执行过程

1. 进程是进程实体的运行过程

2. 进程是系统进行资源分配和调度的一个独立单位 

## 进程的特征

- 结构特征：进程由程序、数据和进程控制块三部分组成。

- 动态性：进程的实质是进程实体的执行过程

    > 动态性是**最基本的特征**。

- 并发性：指多个进程实体同存与内存中，且能在一段时间内同时运行。

- 独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。

- 异步性：进程按各自独立的、不可预知的速度向前推进。

## 状态及转变

1. 进程的三种基本状态

    - 就绪状态(Ready)：已分配到CPU外的所有资源，一旦得到CPU就立 即可以运行

    - 执行状态(Running)： 正在CPU上运行的进程所处的状态

    - 阻塞状态(Block) ： 进程正在等待某一事件发生，分给CPU也无法运 行，称该进程处于阻塞(等待/睡眠/封锁)状态

    ![image-20211224145736879](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224145736879.png)

2. 进程的创建和终止状态以及挂起

    - 创建状态：进程创建工作尚未完成，不能被调度运行时的状态
    - 终止状态：终止后进程移入该状态，它不再有执行资格，保留记录等供其他进程收
    - 进程挂起：将内存中的进程调到外存上去，腾出来的 空间接纳更多的进程，这一处理称为挂起 (Suspend)

- 不带挂起的状态转换图

![image-20211224150612097](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224150612097.png)

- 带挂起的状态转换图

![image-20211224150726987](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224150726987.png)



## 创建进程步骤

1. 进程创建工程

    - 申请空白PCB（PCB表是有限的） 
    - 为新进程分配资源，比如内存 
    - 初始化PCB：填写有关信息，例如标识符， 处理机状态，进程优先级等 
    - 插入就绪队列

2. 进程终止的过程

    - 根据标识符，从PCB集合中检索出终止进 程的PCB，读出进程状态 
    - 若为执行态，终止执行，置调度标志真
    - 若有子孙进程，终止它们 
    - 将进程所拥有的资源归还父进程或系统 
    - 移出所在队列（PCB）

    

## 线程概念

1. 线程的定义

    - 可理解为“轻量级进程”，是进程中的一 个实体

    - 引入线程后，进程作为系统资源（除CPU之 外）的分配单位，线程作为被系统独立调 度和分派的基本单位

2. 线程的特征

    - 线程状态：线程作为基本的调度单位，其状态有：就绪、 运行、阻塞等
    - 线程控制块TCB：每个线程配置一个线程控制块TCB，将用于控 制和管理线程的信息（如寄存器映像、线程优 先数、线程状态信息等）

3. 线程技术典型适用场景 

    - 程序的多个功能需要并发运行

    - 提高窗口程序的交互性 

    - 改善程序结构 

    - 多核CPU上的应用，充分发挥多核功能

        ![image-20211224152328439](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224152328439.png)





## 临界资源和临界区

1. 进程同步：

    - 多个进程为完成某种任务而合作使用某种 资源，不但不能同时用，谁先用谁后用也 有严格约束

    - 体现进程间协同关系（直接制约关系）


2. 临界资源：

    - 一段时间内仅允许一个进程访问的共享资 源，可能是硬件和软件（如变量、内存缓 冲区等）

    - 对临界资源的访问，必须互斥进行


3. 临界区

    - 进程体中使用临界资源的代码段

    - 注意：临界区是对某一临界资源而言的， 对于不同临界资源的临界区，它们之间不 存在互斥

    - 访问临界区的原则
        - 空闲让进：有效利用临界资源
        - 忙着等待：保证临界资源互斥访问
        - 有限等待：避免陷入”死等“
        - 让权等待：避免陷入”忙等“




## 信号量

信号量是一个非负整数，代表可用资源实体的数量

### PV操作

- 指的是对信号量的操作 
- P操作：wait(s) 或 P(s) 

```c
P(s)
{
	While s<=0;
        s=s-1;
}
```

- V操作：signal(s) 或 V(s) 

```c
V(s)
{
	s=s+1
}
```

- P、V操作是原语（由开/关中断指令实现）

### 类型

#### 整型信号量

- 整型信号量是一个整型值

- 记录型信号量用记录型数据结构来表示

    ![image-20211224162924625](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224162924625.png)

![image-20211224162952581](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224162952581.png)

![img](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225143026.png)

#### 记录型信号量

1. **信号量的value值**

- \>=1 ：临界资源可用数
- =0 ：无临界资源可用
- <0 ：value的绝对值就是因等待该临界资源 而阻塞的进程数

2. **信号量机制应用**

- 用于实现 *互斥*

    使用方法： *（注意：对于不同的临界资源，需要设置 不同的互斥信号量）*

    - 1分析并发进程的关键活动，划定临界区 

    - 2设置互斥信号量mutex，初值为1 

    - 3进入临界区之前对信号量执行P操作 

    - 4退出临界区后对信号量执行V操作

![image-20211224163557265](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224163557265.png)

![image-20211224163610319](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224163610319.png)

- 用于实现 *同步*

    使用方法：

    - 分析问题，找出“一前一后”的同步关系 

    - 确定同步信号量S所需个数，设置对应初值 

    - 在“前操作”之后对信号量执行V操作 

    - 在“后操作”之前对信号量执行P操作	

    ![image-20211224163937154](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224163937154.png)

- 用于实现前趋关系

    使用方法：

    - 分析问题，画出前趋图，把每一对前趋关系 都看成一个同步问题 

    - 为每一对前趋关系设置同步信号量S，初值 为0 

    - 在每个“前操作”之后对信号量执行V操作 

    - 在每个“后操作”之前对信号量执行P操作

        ![image-20211224164258035](https://hongv8.oss-cn-beijing.aliyuncs.com/img/image-20211224164258035.png)

- 实现互斥VS实现同步

    - 相同之处
        - P、V操作成对出现
    - 不同之处
        - 对于同一个信号量互斥在同一进程操作，而 同步不在同一进程操作

#### AND型信号量

- AND型信号量适用于同时需要多种临界资源且 每种临界资源占用一个 
- 基本思想：在一个原语中申请整段代码需要的多个临界资源，要么全部分配给它，要么一个都不分配
- 相应的P操作记为Swait，V操作记为Ssignal

#### 信号量集

1.信号量集适用于更一般的场景

- 同时需要多种临界资源 
- 每种临界资源占用数目不同 
- 每种可分配的资源存在一个各自不同临界值

2.信号量集的P、V操作

-  Swait(S1 , t1 , d1 ; ...; Sn, t n , d n ); 
-  Ssignal(S1 , d1 ; ...; Sn, d n ); 
-  下限值 t i：用于信号量的判断条件，当资源 数量低于t i时，不予分配 
-  需求量di：代表对资源 i 的申请量

3.几种特殊情况

-  Swait(S, d, d)：只有一个信号量S，每次申 请d个资源，当少于d个时，便不分配 
-  Swait(S, 1, 1)：蜕化为一般的记录型信号量 (S>1时)或互斥信号量(S=1时) 
-  Swait(S, 1, 0)：可作为一个可控开关
    -  当S1时，允许多个进程进入临界区 
    -  当S=0时，禁止任何进程进入临界区

4.基本思路：在AND型信号量的基础上进行扩充，在一次 原语操作中完成所有的资源申请

​	



# 三	调度与死锁

1. **理解**：调度的基本概念；调度的基本准则；调度的方式与过程；死锁的概念；死锁的预防和避免；死锁的检测和解除
2. **掌握**：典型调度算法；系统安全状态银行家算法
3. **应用**：能够使用银行家算法分析解决问题

## 处理机调度

### 调度层次

- 高级调度<font color='red'>（外存—>内存）</font>
    - 也称**作业调度**或长程调度
    - 任务：用于决定把外存上处于后备作业队列上的哪些作业调入内存，为之创建进程，并将进程加入就绪队列
    - 主要用于多道批处理系统，不适用于分时、实时系统
    - 时间：分钟、小时或天
- 中级调度<font color='red'>（挂起—>就绪）</font>
    - 也称**内存调度**或中程调度
    - 任务：涉及进程在内外存间的交换，决定把哪些具备运行条件的挂起就绪进程调入内存成为就绪状态
    - 时间：介于高级、低级调度之间
- 低级调度<font color='red'>（就绪—>运行）</font>
    - 也称**进程调度**或短程调度
    - 任务：用于选择为哪个就绪进程分配CPU执 行，让其进入运行状态
    - 时间：毫秒级（10ms~100ms）

![image-20211224121118673](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224121120650-1711699776.png)

### 处理机调度算法的目标

- 资源利用率：使系统中的处理机和其他资源都尽可能忙碌
- 公平性：诸进程都获得合理 CPU 时间
- 平衡性：使各种 I/O 设备得以充分利用
- 策略强制执行

## 周转时间

1. **周转时间**：指作业被提交给系统开始，到作业完成为止的这段时间间隔

2. 包括：

    - 作业在外存 *后备队列等待调度* 的时间
    - 进程在*就绪队列*上 *等待进程调度* 的时间
    - 进程在CPU上 *执行* 的时间
    - 进程 *等待I/O* 操作完成的时间

3. 平均周转时间：周转时间/作业数量

    >平均周转时间越小，系统吞吐量就越大

![image-20211225125241404](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225125241.png)

4. 平均带权周转时间：

    > 平均带权周转时间越小 ，系统对短作业越有利

![image-20211225125428965](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225125429.png)

![image-20211225125443029](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225125443.png)

## 作业状态

**作业的三个状态**

- 后备状态：已经提交到外存的作业后备队列，等待调度装入

- 运行状态（驻留状态）：作业被调度选中，已经装入内存，处于宏观的运行状态

- 完成状态：作业运行完成或异常结束，系统将回收作业的JCB和分配的资源，并将作业结果输出

![image-20211224160849305](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224160849741-1669637536.png)





## 作业调度算法

### 先来先服务

1. **算法思想**： 
    - 按照作业到达的先后次序来进行调度，即优先考虑在系统中<font color='red'>等待时间最长</font>的作业，不考虑作业所需执行时间的长短是最简单的调度算法

![image-20211224122003826](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224122004591-135220458.png)

2. **优点**：
    - 简单，容易实现

3. **缺点：**

    - 不区分作业长短，对短小作业不利

    - 没考虑作业的优先级





### 短作业优先（SJF）

1. **算法思想**： 
    -  系统从后备作业中选择<font color='red'>运行时间最短</font>的作业装入内存

![image-20211224122306182](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224122306821-1126752134.png)

2. **优点：**
    - 对给定的一组作业平均等待时间最小
    
3. **缺点**： 
- 必须预知作业的运行时间，这种预知有可能不太准确
  
- 对长作业不利，也未考虑紧迫程度

### 优先级

1. **算法思想**： 
    - 基于作业的紧迫程度，由<font color='red'>外部赋予作业响应的优先级</font>，系统从后备队列中选择优先级最高的作业装入内存当作业进入系统，系统根据用户级别、作业类别、作业运行时间要求等为作业赋予一个优先级

![image-20211224122623814](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224122624364-850276826.png)

2. **优点：**

    - 紧迫型作业可尽早处理

3. **缺点**： 
- 低优先级的进程可能永远不能运行
  
- 据说1973年关闭MIT的IBM7094时，发现一个低优先级进程是1967年提交但一直未运行

### 高响应比（HRRN）

1. **算法思想**： 
    -  系统从后备队列中选择<font color='red'>响应比最大</font>的作业装入内存
2. **响应比：**

<img src="https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225145141.png" alt="image-20211225145141541" style="zoom: 50%;" />

<img src="https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225145212.png" alt="image-20211225145151938" style="zoom: 50%;" />



![image-20211224122848822](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224122849363-142066606.png)

 **优点：**

- 优先级动态变化，折衷考虑到作业进入系统的先后次序
- 又顾及到作业的运行长度保证长作业等待足够时间后，必然能执行

 **缺点**：

- 每次调度都要计算每个作业响应比，开销大



## 进程调度算法

### **进程调度的任务**

- 保存处理机的现场信息
- 按某种算法选取进程
- 把处理器分配给进程

### 进程调度方式

- 非抢占式
    - 把处理机分配给某进程后，该进程便一直执行至完成或发生某事件而被阻塞时，才再把处理机分配给其它进程
- 抢占式：
    - 允许调度程序根据某种原则，强制停止正在执行的进程，将处理机重新分配给另一进程
    - 适用于分时、实时系统
    - **抢占的原则：**
        - 优先权原则
        - 短进程优先原则
        - 时间片原则

<font color='red'>进程**调度方式**强调的是： **是否允许抢占**</font>

<font color='red'>进程**调度算法**强调的是：如何从就绪队列中 **取出进程分配CPU**</font>

非抢占式和抢占式 都可以采用以下的调度算法  进行调度处理操作

> ---
>
> > 常用的进程调度算法：
>
> 1. 先来先服务 FCFS 算法
> 2. 短进程优先 SPF 算法
> 3. 高响应比优先 HRF 算法
> 4. **轮转调度 RR 算法**
> 5. **优先级调度 HPF 算法**
> 6. **多级反馈队列调度算法**
>
> - <font color='red'>在作业调度算法中，介绍了前三种调度算法，下面介绍4.5.6三种调度算法</font>


### 轮转调度算法（RR）

1. **算法思想**： 
    - 把 CPU 时间划分成若干小单位——**时间片** ，进程**轮流使用** CPU 的一个时间片
    - 当进程的 **时间片耗尽**或者**运行完毕** 时，系统再次将 CPU 分配给新的队首进程
    - 若进程尚未完成，系统将其送往就绪队列的**末尾**
2. **该算法中进程切换的时机：**
    - 当前进程运行结束
    - 一个时间片运行结束
    - 正在运行的进程因事件受阻主动放弃 CPU
3. **时间片的确定：**
    - 略大于一次典型的交互所需时间，使大多数交互式进程能在一个时间片内完成
    - 进程的道数 较多时， 时间片 就选得小一些；反之，可选得大些
    - 系统要求的响应时间 比较苛刻时， 时间片 就选得小一些；反之，可选得大些

### 优先级调度算法（HPF）

1. **算法思想:**
    - 优先选择就绪队列中 最高优先级 的进程投入运行
    - 优先级以 优先数 来决定，优先数是一个与进程关联的固定区间的整数，例如 0~255
    - 包括 抢占和非抢占 两种方式，抢占方式常用于严格的实时系统
2. **确定进程优先级：**
    - 静态优先级：进程 创建时就确定 运行期间不变
    - 动态优先级：进程创建时先赋予一个优先级，然后其值 随着 进程的推进 或 等待时间 增加而改变

### 多级反馈队列调度算法（MFQ）

1. **算法思想：**	
    - 设置**多个就绪队列** ，每个就绪队列赋予 **不同的优先级** ，分配给 不同的时间片
    - 优先级**高**的队列**优先**调度 ；当优先级高的队列为空时，再调度低优先级队列
    - 第 **1 至 n<sub>1</sub>** 队列采用 **FCFS** 算法，第 **n** 队列采用**RR** 算法， 进程可以在不同队列间移动
2. **调度过程：**
    - 当进程进入内存后（ 第一次就绪） 进入第一级队列的末尾 ，按照 FCFS 原则等待调度
    - 当运行进程 用完一个时间片 ，放弃 CPU 时， 转入下一级队列的末尾 等待调度
    - 等待进程 被唤醒时 进入原来的就绪队列
    - 系统正为第 i 队列的进程服务时，若 有新进程 进入 1 至 (i-1) 队列中，则 正在运行进程放回第 i 队列的**末尾（当前队列的最后）**，系统为新进程服务

![image-20211225163907867](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225163908.png)



## 死锁

### 定义

1. **什么是死锁？**
    - 一组相互竞争系统资源的进程间的永久阻塞
    - 现象：每个进程获得了一部分资源，又申请另外的资源，得不到而转入阻塞，若无外力作用，这些进程会一直阻塞下去

2. **死锁产生的原因**
    - 动态资源分配策略
    - 资源可用数量少于需求数量
    - 进程并发过程的偶然因素（进程推进顺序不

当）

### 必要条件

1. **死锁产生的必要条件**
    - 互斥条件
        - 进程对所需分配到的资源进行排他性使用，即在一段时间内，某资源只能被一个进程占用。若此时有其他进程请求该资源，则请求进程只能等待，直到占有该资源的进程用完释放
    - 请求和保持条件
        - 进程以经保持至少有一个资源，但是又请求新资源，不够请求的资源被其他进程占用，此时请求进程被阻塞，但对自己持有的资源保持不放
    - 不可抢占条件
        - 进程以获得的资源在未使用完之前不能被抢占，只能由进程使用完后自己释放。
    - 循环等待条件
        - 当发生死锁时，必然存在一个‘进程——资源’的循环链，即进程集合{P0，P1,  P2  。。。Pn}，中的P0，正在等待一个P1占用的资源，P1,正在等待P2占用的资源，。。。。，Pn，正在等待P0占用的资源。

### 处理方法

1. 预防死锁：资源静态分配法
2. 避免死锁：银行家算法
3. 检测死锁：资源分配图简化法
4. 解除死锁：强制结束进程

> 预防死锁和避免死锁是事前处理
>
> 检测死锁和解除死锁是事后处理

#### **预防死锁**

**概念**：基本思想:通过预先设置某些限制条件，去破坏死锁四个必要条件中的一个或多个，来防止死锁，

较易实现，广泛使用

1.  破坏**请求和保持条件**：
    - 协议一：使用静态资源分配策略，即所有进程要一次性地申请在整个运行过程中所需的全部资源。若系统有足够资源则完全分配     
        - **优点**: 进程一定不会发生死锁
        - **缺点：**资源被严重浪费，进程容易发生饥饿现象   
    
    - 协议二：允许一个进程只获得运行初期所需的资源便开始运行，运行过程中逐步释放已用毕的资源，然后再请求新的所需资源
    
    - 协议二：可提高设备的利用率，减少进程饥饿的概率
    
2.  破坏**不可抢占条件**：
    - 做法：一个已拥有资源的进程，若它再提出新资源要求而不能立即得到满足时，它必须释放已经拥有的所有资源，以后需要时再重新申请
    - 实现复杂、要付出很大的代价 
    
3.  破坏**循环等待条件：**

    - 做法：使用按序资源分配策略，即给系统中的所有资源一个确定的唯一号码，所有分配请求必须以序号上升的次序进
        - **优点**：资源有效利用效率会高于静态资源分配策略
        - **缺点**：不方便增加新的设备，限制用户编程

4.  **总结：**
    - 预防死锁是在资源分配策略上做限制，让死锁根本没有机会发生
    - 资源利用率上都有所牺牲，可能导致系统吐量的降低
    - 预防死锁属于**静态**预防方法

#### 避免死锁

基本思想：不事先采取限制去破坏产生死锁的条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生

避免死锁是一种**动态**避免方法

1. **安全状态**

- 如果系统能按某种顺序<P1,P2,…,Pn>，称为安全序列）为每个进程分配其所需的资源
- 使得所有进程都能依次运行完成，称系统处于安全状态
- 如果不存在这样一个安全序列则称系统处于不安全状态

> 例：某系统中有三个进程p1,p2,p3，以及12台磁带机资源。其中P1共要求10台，P2共要求4台，P3共要求9台。在T0时刻，p1,p2,p3分别获得5、 2、2台，尚有3台空闲。
>
> ![image-20211224161942536](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224161943428-130882806.png)
>
> ![image-20211224162001309](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224162002390-763922468.png)
>
> 若不按安全序列分配资源，则系统可能会由安全状态进入不安全状态
>
> - 在T0以后，P3请求1台磁带机，若系统分配给它，则系统进入不安全状态。因此当P3申请资源时，尽管系统中有资源也不能分给它![image-20211224162150051](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224162150532-410464160.png)

2. **辨析：不安全状态与死锁**

-  安全状态是没有死锁的状态
-  死锁状态是不安全状态
-  不是所有不安全状态都是死锁状态

3. 代表性的避免死锁算法—**银行家算法**

- 该算法对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统处于不安全状态，则不予分配，否则予以分配

- 可用资源向量Available[m]

    - 它是一个含有m个元素的数组，其中每个元素代表一类可利用资源的数目

- 最大需求矩阵Max`[n][m]`

    - 表示n个进程对m类资源的最大需求

- 分配矩阵Allocation`[n][m]`

    - 表示每个进程分配的每类资源数

- (4) 需求矩阵Need`[n][m]`

    - 表示每个进程还需要的各类资源的数目

    Need`[i][j]`=Max`[i][j]`- Allocation`[i][j]`

4. **银行家算法的执行步骤**

当进程Pi提出资源申请时，系统执行下列步骤： 

- 若Requesti [j]≤Need`[i][j]`，转(2)；否则错误返回（超出进程需求） 
- 若Requesti [j]≤Available[j]，转(3)；否则进程等待（尚无足够资源） 
- 系统试探着分配资源给Pi ，则修改数
    - Available[j]:=Available[j]-Requesti [j];
    - Allocation`[i][j]`:=Allocation`[i][j]`+Requesti [j]; 
    - Need`[i][j]`:=Need`[i][j]`-Requesti [j]; 
- 对修改后的数据执行安全性算法，若系统新状态是安全的，则分配完成，若系统新状态是不安全的，则恢复原状态，进程等待

5. **银行家算法实例**

假设系统中有三类资源A(10)、B(5)、C(7)和5个进程P0~P4。T0时刻的系统资源分配情况如下表：

- 问题一：T0时刻的安全性

    ![image-20211224164727572](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224164727805-33800503.png)

    - 假设系统中有三类资源A(10)、B(5)、C(7)和5个进程

    P0~P4。T0时刻的系统资源分配情况如下表：

    - 问题一：T0时刻的安全性。

        ![image-20211224164828820](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224164829049-352824707.png)

    - ![image-20211224164854680](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224164855144-670874252.png)

- 假设系统中有三类资源A(10)、B(5)、C(7)和5个进程P0~P4。T0时刻的系统资源分配情况如下表：

    - 问题二：T0时刻P1发出Request1 (1,0,2)，能否分配？

    ![image-20211224165016065](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224165016314-1887701062.png)

- 假设系统中有三类资源A(10)、B(5)、C(7)和5个进程

    P0~P4。T0时刻的系统资源分配情况如下表：

    - 问题二：T0时刻P1发出Request1 (1,0,2)，能否分配？

    ![image-20211224165108961](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224165109315-293854361.png)

![image-20211224165139884](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224165140319-1902761581.png)

- 假设系统中有三类资源A(10)、B(5)、C(7)和5个进程P0~P4。T0时刻的系统资源分配情况如下表：

    - 问题三：在(2)基础上P4发出Request4 (3,3,0)，能否分配？

    ![image-20211224165517135](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224165517487-246323752.png)

- 假设系统中有三类资源A(10)、B(5)、C(7)和5个进程P0~P4。T0时刻的系统资源分配情况如下表：

    - 问题四：在(2)基础上P0发出Request0 (0,2,0)，能否分配？

    ![image-20211224165640805](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224165641178-225952439.png)

    ![image-20211224165750427](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224165750729-1171892810.png)

###  **死锁的检查与解除**

- **死锁检测时机**
    - 当进程等待时检测死锁
    - 定时检测
    - 系统资源利用率下降时检测死锁
- **死锁解除**
    - 通过撤消或挂起一些进程，以回收一些资源分配给处于阻塞状态的进程，使之转为就绪状态
    - 实现难度大，但可获得较好的资源利用率和系统吞吐量
- **死锁解除方法**
    - 抢占资源
    - 终止或撤销进程，直到打破循环环路，使系统从死锁状态中解放

## 资源分配图

> 死锁状态的充分条件是：当且仅当资源分配图是不可完全简化的
>
> 不是所有不安全状态都是死锁状态。因为下一步可能导致死锁，而当前不一定

- **资源分配图(Resource Allocation Graph)**
    -  圆圈代表一个进程，方框代表一类资源
    -  方框中的圆点（圈）表示资源实例
    -  请求边：进程指向方框
    -  分配边：方框指向进程



![image-20211224170219546](https://img2020.cnblogs.com/blog/2305021/202112/2305021-20211224170219749-2064260763.png)

1. **资源分配图分析**
    - 资源分配图中没有环路，则系统中没有死锁，如果图中存在环路，则系统中可能存在死锁
    - 每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件

2. **资源分配图化简**
    - 找一个只有分配边的非孤立点进程结点，去掉分配边，将其变为孤立结点
    - 再把相应的资源分配给一个等待该资源的进程，即将某进程的申请边变为分配边
    - 重复以上步骤，若所有进程成为孤立结点，称该图是可完全简化的，否则称该图是不可完全简化的。



# 四	存储器

## 逻辑地址和物理地址

逻辑地址：用户空间中使用的一种地址,又称相对地址

物理地址：存储单元的实际物理单元地址，又称绝对地址



## 地址映射(地址重定位)

将用户程序中的**逻辑地址 ** **转换**  为运行时由机器直接寻址的**物理地址**，这一过程称为地址映射



## 内存分配算法

### 离散

#### 分页存储管理

1. **原理**

- 将一个进程的逻辑地址空间分成若干个大小相等的片称为页(page)，并为各页加以编号，从0开始
- 同时把内存空间分成与页面相同大小的若干个物理块，称为块或页框(frame)，也从0开始为各块编号

2. **分配：**以块为单位,将进程的若干个页分别装入到多个离散不相邻的物理块中

![image-20211224121925566](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224121925566.png)

3. **用位视图记录内存使用情况**

- 每一位对应内存上的一个物理块，取值0和1分别表示空闲和占用

    ![image-20211224122305120](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224122305120.png)

- 计算

![image-20211224122602133](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224122602133.png)

4. **页面地址结构**

![image-20211224123130380](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224123130380.png)

5. **存在的问题**

- 由于每次对数据的存取都要先访问页表，而页表在内存中，因此每条访问内存的指令需要访问两次内存，运行速度要下降一半
- 根据程序执行时的局部性原理，可能连续多次查的都是同一个页表项

6. **解决办法**

- 在地址变换机构中，增设一个具有并行查寻能力的特殊高速缓冲寄存器，称为“联想存储器TLB”或“快表”，快表的速度是内存

    速度的数倍或数十倍

- 快表中存放最近访问的若干个页表项，以加快地址变换的过程

![image-20211224123828893](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224123828893.png)

7. **两级页表和多级页表**

- **两级页表**
    - 将页表分页，每页离散地存放在不同的物理块中，同时为离散分配的页表再建立一张页表，称为外层页表，其每项记录了页表页面的物理块号

![image-20211224233624337](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224233624337.png)

> **例：**
>
> ​	![image-20211224233649509](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224233649509.png)

- 地址变换结构

    ![image-20211224233722662](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224233722662.png)

    - 对于正在运行的进程，必须将其外层页表调入内存，而对页表则只需调入一页或几页（最近使用的）即可

    - 因此在外层页表项中增设一个状态位S，用于表示该页表是否调入内存

- 多级页表
    - 采用多级页表机制，通常各级页表的大小不超过一个页面

    ![image-20211224233838668](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224233838668.png)

    - 优点
        - 离散存储，利于大进程装入
        - 解决了外部碎片问题，只有很少的页内碎片，提高了内存利用率

    - 缺点

        - 页表占用大量内存空间
        - 页面共享不易实现

8. **常考题型**

![image-20211224123426192](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224123426192.png)

![image-20211224123439256](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224123439256.png)

![image-20211224123450345](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224123450345.png)

#### 分段存储管理

- 分段技术

    - 段是一个逻辑单位，通常一个程序可分为若干个段，如主程序段、子程序段、数据段以及堆栈段等，每个段都从0开始编址

    - 分段后，源程序使用的符号地址是二维的：<段名，变量名> 

    - 编译后的逻辑地址：<段名，段内偏移量>

![image-20211224124012763](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224124012763.png)

- 原理

    - 基于分段技术，将作业的地址空间按照自身的逻辑关系划分为若干个段（由编译程序支持完成）

    - 为每个段设置段号，段号从0开始

    - 以段为单位分配内存，一段占用一块连续内存空间，但各段之间可以离散存放

![image-20211224124108129](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224124108129.png)

- 地址结构

    - 段有最大长度限制，但不要求每个段的长度都相等
    - 段长由逻辑信息组的长度决定

![image-20211224124256106](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224124256106.png)

- 优点

    - 分段共享非常方便
    - 便于信息保护、动态链接

- 缺点

    - 内存仍然按分区管理，会产生外部碎片

- 分页和分段的区别

    - **可见与不可见**
        - 分页是系统活动，用户无法介入，页的大小固定
        - 分段是用户可见的，段大小可变
    - **物理单位与逻辑单位**
        - 页是信息的物理单位，不是完整的逻辑单位
        - 段是完整的逻辑信息单位
    - **地址空间**
        - 分页的作业空间是一维的
        - 分段的作业空间是二维的
    - **内存管理**
        - 分页的内存管理效率高，没有外部碎片，只有小的内部碎片
        - 分段产生在外部碎片，内存管理效率降低
    - **信息共享**
        - 分页不易实现共享
        - 逻辑分段，每个分段都有完整的功能，方便代码共享、保护

#### **段页式存储管理**

- 原理

    - 将分页和分段两种存储管理方式结合起来

    - 系统内存分块（划分成大小相等的页框）

    - 用户程序分段、段内分页，页的长度等于内存中的页框大小

    - 每块装入一页，各块之间可以不连续

        ![image-20211224124849481](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224124849481.png)

- 地址结构

    ![image-20211224124921696](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224124921696.png)

- 地址变换结构

    - 系统配置一个段表寄存器，用来存放段表始址和段长

    - 段页式系统中，每访问一个指令或数据，需访问三次内存——增设一个高速缓存寄存器来提高速率

        ![](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224125402978.png)

- 优点

    - 内存利用率高，又便于保护、共享等控制

- 缺点

    - 比较复杂
    - 每访问一个数据，需访问三次内存

- **计算**

![image-20211224125701479](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224125701479.png)

![image-20211224125717507](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224125717507.png)

### 连续

最早出现的一种存储器分配方式，为一个用户分配一个连续的内存空间

分为四类：

##### 单一连续分配

- 内存用户区的全部空间只存放一个进程，适用于单用户单任务系统，除了嵌入式系统外，其他的计算机不再使用

##### 固定分区分配

- 将内存空间划分为若干个固定大小的区域，每个分区一道作业

- 将分区按其大小排队，建立一张分区使用表，每个分区对应一个表项

    ![image-20211224230754880](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224230754880.png)

- 方法

    - 分区大小相等
        - 缺乏灵活性；程序太小时造成浪费；程序太大时，无法运行
        - 适用于一台计算机控制多个相同对象的控制系统
    - 分区大小不等
        - 划分多个较小的分区、适量的中等分区及少量的大分区

- 缺点

    - 分区大小在系统生成阶段事先设置，可能出现大作业无法装入，小作业装入大分区出现“内部碎片”，造成存储空间的浪费
    - 分区数目在系统生成阶段已经确定，限制了系统活动进程的数目

##### 动态分区分配(可变分区分配)

- 不预先划分内存分区，根据进程的实际需要，动态为之分配内存空间
- 作业装入内存时，分配分区的大小正好适合作业大小的需要

---

**<font color='red'>以下是内存连续分配算法中动态分区分配的主要算法</font>**



### 动态分区分配算法

> 动态分区分配分为
>
> - 基于顺序搜索
>     - **首次适应算法**
>     - **循环首次适应算法**
>     - **最佳适应算法**
>     - **最坏适应算法**
> - 基于索引搜索
>     - **快速适应算法**
>     - **伙伴系统**
>     - **哈希算法**

#### 首次适应算法(first fit)

- 基本思想
    - 系统按空闲区首址递增的次序组织空闲分区表（或空闲链表）
    - **分配：**每次进行内存分配时，从头到尾顺序扫描空闲分区表（或空闲链表），找到的第 1块能够满足要求的空闲区，立即分配出去
- 特点
    - 低址内存使用频繁，尽可能地利用低地址空间，从而保证高地址空间有较大的空闲区
- 缺点
    - 低址部分不断被划分，留下许多不能被任何作业使用的、极小的空闲分区，称为碎片
    - 外部碎片的产生，不但会降低内存的有效利用率，还会增加查找可用空闲分区时的开销
    - **缺点总结**
        - 低地址不断会划分，易产生外部碎片

#### 循环首次适应算法(next fit)

- 基本思想

    - 系统将内存分区按地址递增顺序登记到空闲分区表（循环队列）或空闲循环链表中

    - **分配：**每次进行内存分配时，从起始查询指针（指向上次找到的空闲区的下一个）开始顺序扫描空闲分区表（或空闲链表），找到的第1块能够满足要求的空闲区，立即分配出去

        ![image-20211224231649153](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224231649153.png)

- 特点

    - 空闲区分布均匀
    - 减少了查询空闲分区时的开销

- 缺点

    - 缺乏大的空闲区

#### 最佳适应算法(best fit)

- 基本思想
    - 系统按空闲区大小从小到大的次序组织空闲分区表（或空闲链表）
    - **分配：**每次进行内存分配时，**总是找到能满足要求、又是最小的空闲分区分配出去**
- 特点
    - 减少了将大空间区多次分割造成的空间浪费
- 缺点
    - 每次分配和回收后都要对空闲区表重新排序，系统开销较大
    - 容易留下许多难以利用的外部碎片

#### 最坏适应算法(worst fit)

- 基本思想
    - 系统按空闲区大小从大到小的次序组织空闲分区表（或空闲链表）
    - **分配：**每次进行内存分配时，**总是挑选能满足要求、又是最大的空闲分区分配出去**
- 特点
    - 缓解了由外部碎片引起的浪费
- 缺点
    - 每次分配和回收后也要对空闲区表重新排序，系统开销较大
    - 容易缺乏大的存储区，对大作业的运行不利

#### 快速适应算法(quick fit)

> 又称分类搜索算法

- 基本思想
    - 将空闲分区根据容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，再对所有类别设一个索引管理表
    - 每次分配时根据所需大小**从能容纳它的最小空闲区对应类别中取第一块**，不分割
- 特点
    - 查找效率高
- 缺点
    - 回收算法复杂，系统开销大
    - 一个分区只属于一个进程，存在内部碎片
    - 索引管理表要占用空间，以空间换时间

#### 伙伴系统(buddy system)

- 基本思想
    - 无论已分配分区或空闲分区，分区大小均为2的K次幂(1<=k<=m)，不同大小区形成K个空闲分区链表
    - 系统开始运行时，整个内存区是一个大小为2m的空闲分区，运行过程中不断划分形成若干个不连续的空闲分区
    - **分配：**为进程分配长度为n的空间时
        - 先计算一个i值，使得2i-1<n<=2i 
        - 然后在分区大小为2i的空闲分区链表中查找，若存在一个空闲分区，立即分配
        - 若未找到，则在分区大小为2i+1的空闲分区链表中查找，若存在一个空闲分区，则将分区划分为两个分区（称一对伙伴），其中一个分配，另一个加入到分区大小为2i的空闲分区链表中
- 回收

![image-20211224232139877](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224232139877.png)

#### 哈希算法

- 基本思想

    - 构建以空闲区大小为关键字的哈希表，每个表项对应一个空闲分区链表头地址

    - **分配：**每次分配时，根据所需空间分区大小，通过哈希函数计算，快速得到在哈希表中的位置，从而得到相应的空闲分区链表，实现最佳分配策略

![image-20211224232258988](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224232258988.png)

- 外部碎片问题

    - 解决方法一
        - 在分割空闲区时，若剩余部分小于门限值，则不再分割此空闲区，将整个分区分配给请求者
        - 例如操作系统规定门限值为1K
    - 解决方法二
        - 移动作业空间

![image-20211224232410223](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224232410223.png)

1. **动态可重定位分区分配**

    - **紧凑**

        - 通过移动内存中作业的位置，将原来多个分散的小分区拼接成一个大分区的方法
        - 又称为“拼接”
        - 由于作业已经装入内存，因此作业的移动需变换程序和数据的地址

    - 装入方式


![image-20211224232607443](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224232607443.png)

- 基本思想

    - 基于动态重定位的原理，当系统对内存进行“紧凑”时，用移动后的新的起始地址去替换重定位寄存器的原始地址即可

    - **分配：**与动态分区分配算法基本相同，差别在于增加了“紧凑”功能

![image-20211224232650176](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224232650176.png)

- 优点

    - 作业可以在内存中移动位置
    - 紧凑提高了内存利用率

- 缺点

    - 系统对内存进行频繁紧凑，须为之付出很大的开销，实用价值较低

## 内部碎片和外部碎片

**内部碎片**

- 指进程获得的空间大于需求的空间时，多出来的空闲区
- 内部碎片的产生会降低内存的有效利用率

**外部碎片**

- 指当内存空间不断被划分，留下许多不能被任何作业使用的、极小的空闲分区，称为碎片或零头
- 外部碎片的产生，不但会降低内存的有效利用率，还会增加查找可用空闲分区时的开销

## 对换Swap

由于阻塞进程占据大量内存空间，许多作业在外存而不能进入内存运行，因此引入对换，对换是改善内存利用率的有效措施

**概念**

- 指的是把内存中暂时不能运行的进程或者暂时不用的程序和数据，调到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程和进程所需要的程序和数据调入内存

**分类**

- 整体对换(或进程对换)
    - 以整个进程为单位
- 部分对换
    - 在分页或分段式存储管理中，以页或段为单位
    - 只能换出进程的非共享的程序和数据段
- 对换空间
    - 一般从磁盘上划出一块空间供对换使用
    - 磁盘空间分为两部分: 
        - 文件区
        - 对换区

**主要目标**

![image-20211224234505226](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224234505226.png)

## 本章小结

![image-20211224234549290](https://image-1308080811.cos.ap-shanghai.myqcloud.com/img/image-20211224234549290.png)



# 五	虚拟

> 不必全部装入，运行不必一直驻留

## 虚拟存储实现技术

1. 基于分页的虚拟存储： 页面 换入换出
2. 基于分段的虚拟存储： 段面 换入换出
3. 基于段页的虚拟存储： 页面 换入换出

## 请求分页中的内存分配

### 最小物理块数的确定：

1. 最小物理块数 ：指 能保证进程正常运行所需的最小物理块数
2. 最小物理块数与计算机的硬件结构有关，取决于 指令的格式、功能和寻址方式
    - 若单地址指令且采用直接寻址方式
    - 则所需的最少物理块数为 2 ，一块放指令，一块放数据

### 物理块的分配与置换策略

![image-20211225191126478](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225191126.png)

> 固定分配策略：
>
> 1. 平均分配算法
> 2. 按比例分配算法
> 3. 按进程优先级分配算法

1. 平均分配算法

- 将系统中所有可供分配的物理块， 平均分配给各个进程
- 例如当系统中有 100 个空闲物理块，有 5 个进程需运行，每个进程可分得 20 个物理块
- 缺点： 未考虑各进程的大小，对短作业有利

2. 按比例分配算法：

- 根据进程的大小按比例分配物理块
- 若系统共有n个进程，每个进程的页面数为Si，所有进程页面总数为S

- 假定系统中可用的物理块总数为m
- 则给第i个进程分配的物理块为

<img src="https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225192232.png" alt="image-20211225192232152" style="zoom: 67%;" />

3. 按进程优先级分配算法：

- 为了让重要、紧迫的作业尽快完成， 应为它分配较多的内存空间
- 因此可将内存中所有物理块分成两部分：
    - 一部分按比例地分配给各进程
    - 另一部分则根据各进程的优先权进行分配，为 高优先级进程适当地增加 其相应份额

## 页面置换算法

### 最佳置换算法 (Optimal）

1. **基本思想：**

    > 看未来，置换最久之后才使用的

- 选择 永不使用的 ，或者是 在**最长时间内不再被访问** 的页面 予以淘汰
- 保证获得最低的缺页率， 具有最好的性能，
- 但难以实现，是一种 理想化的理论算法

2. 用途： 主要用于评价其他算法



### 先进先出置换算法 (FIFO）

> 看过去，置换最早进入的

1. 基本思想：

- 总是 淘汰最先进入内存的页面 ，即选择在内存中**驻留时间最久**的页面予以淘汰

2. 实现： 

- 把已调入内存的 页面按先后次序链接成队列
- 设置一个 替换指针 ，指向最早页面

3. 优点：

- 容易理解和实现

4. 缺点

- 算法思想与进程的实际运行规律不相适应
- 最先装入的不一定是以后不用的，
- 先装入内存者很有可能是主程序常驻模块
- 性能差

### 最近最久未使用置换算法 (LRU）

> 看过去，注意重复出现的

1. 基本思想：

- 根据程序局部性原理，在**较长时间里未被使用**的页面，可能不会马上使用到
- 系统选择 最长时间没有使用 的页予以淘汰

### 时钟置换算法 (Clock）

>又称“最近未用算法 (NRU）

1. **基本思想：**

- 为每页设置一位 访问位 A ，将内存中的所有页面链接成一个 循环队列
- 当页面被访问时，其访问位置为 1
- 当淘汰页面时， 循环扫描队列检查每页的访问位A
- **若为 0 ，则选中淘汰，进行置换**
- **若为 1 ，则将其改为 0 ，让其继续驻留内存，继续循环扫描下一个**

2. **特点：**

- 建立在循环检测基础上的 LRU 近似算法
- 所选的页不一定是最久未用的

3. **缺点：**

- 只关注页面最近是否被访问过
- 没有关注页面是否被修改过
- 是否修改过的页面在被换出时开销大为不同

### 改进的 Clock 置换算法：

1. **基本思想：**

- 考虑置换代价 ，为每页增设一位 修改位 M
- 访问位 A 和修改位 M 组合成四种类型的页面

![image-20211225203542513](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225203542.png)

2. **改进后的处理过程：**

- 从指针当前位置开始，循环扫描队列
    - 寻找第 1 个A=0 且 M=0 的页面将其淘汰
    - 第一轮 扫描期间不修改访问位 A
- 若循环一周找不到第 1 类页面，开始 第二轮 扫描
    - 寻找第 1 个 A=0 且 M=1 的页面将其淘汰
    - 第二轮扫描期间将所有扫描过的页面的 访问位 A 置为 0
- 若第二轮仍没有找到，开始第三轮，操作同第一轮；
    - 若第三轮仍没有找到，开始第四轮，操作同第二轮，此时一定能找到一个淘汰页面

> <img src="https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225203743.png" alt="image-20211225203743744" style="zoom:80%;" />
>
> <img src="https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225203759.png" alt="image-20211225203759511" style="zoom: 80%;" /><img src="https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225203813.png" alt="image-20211225203813260" style="zoom: 80%;" />



## 抖动

1. 定义：
    - 指刚被调出去的页需要马上被调回，刚调回不久又要被调出。 
    - 频繁调入调出 ，以至于 **调度页面所需时间  比  进程实际运行的时间  还多**
    - 导致系统效率急剧下降，甚至系统崩溃
2. 原因：
    - 页面置换算法不合理
    - 进程多，物理页面数太少
3. 预防方法：
    - 限制抖动范围
        页面的置换只允许发生在其本身得到的物理块范围
    - 挂起某些进程，缓解内存拥挤





# 大题

## PV操作

### 前趋图

> 针对信号量解决前趋图题：
>
> - 首先画出自己如何定义的信号量
> - 然后再给出相关代码

**题目：**

![img](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211224164110.jpg)

**答案：**

![img](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225092821.png)





-----

针对下面两道文字描述信号量题的***做题步骤***：

1. 首先找出动作的执行者，作为子函数

2. 确定子函数中的操作，*也就是执行者要进行哪些操作*

3. 找到**同步资源**和**互斥资源**

4. 对两类资源的判断是否存在顺序操作，决定是否需要设置**empty、full**信号量

    > 例如：
    >
    > ​	在货架上，只有先放置了商品，才能售卖商品，a,b并发运行
    >
    > 需要对货架设置**当前还能放**的最大数量	为empty
    > 				   设置**当前已经放**了的数量	为full
    >
    > 1. 对于放置进程：
    >     - 先进行<font color='red'>P(empty)</font>，也就是判断如果再放一个商品，empty-1是否`>=`0
    >         - `>=`0说明当前就算再放一个也没有问题，可以进行下一步操作
    >         - `<`0说明再放一个就放不下了（货架已满），不可以下一步操作，等待
    >     - 成功进行下一步操作（放了一个在货架上）后，需要在最后<font color='red'>V(full)</font>，也就是对full+1
    > 2. 对于售卖进程：
    >     - 先进行<font color='red'>P(full)</font>，也就是判断如果取出一个商品，full-1是否`>=`0
    >         - `>=`0说明当前就算再取出一个也没有问题，可以进行下一步操作
    >         - `<`0说明再放一个就无法取出了（货架为空），不可以下一步操作，退出
    >     - 成功进行下一步操作（放了一个在货架上）后，需要在最后<font color='red'>V(empty)</font>，也就是对empty+1

### 普通互斥信号量

**题目：**

1. 执行者：
    - input、compute
2. 相关操作：
    - input：
        - 采集数据
        - 将数据存入缓冲区
    - output：
        - 从缓冲区取出数据
        - 进行计算
3. 区分资源
    - 互斥资源：单缓冲区
    - 同步资源：无
4. 判断顺序
    - 存在顺序：input先进行存入缓冲区，compute才能进行取出数据

![img](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211224164043.jpg)

**答案：**

![img](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225092954.png)

### 同步信号量（难点）



**题目：**

1. 找到动作执行者：
    - 小和尚、老和尚
2. 确定相关操作：
    - 小和尚：
        - 取桶
        - 去水井提水
        - 倒水进缸内
        - 还桶
    - 老和尚
        - 取桶
        - 从水缸取水
        - 喝水
        - 还桶
3. 区分**有限资源**和**互斥资源**
    - 同步资源：
        - 水桶有三个、缸内能装10桶水
    - 互斥资源：
        - 水井(供一桶取水)、水缸(供一桶入水)
4. 判断顺序
    - 存在顺序：小和尚先打水入缸，老和尚才能从缸中取水

![img](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225073403.jpg)

**答案：**

![EBBF731AAB05DEDCB6D63477DB64AC56](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225110650.png)

![09DDE8F81BD1B82BE3A3A0F0BC3EC2A7](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225110655.png)



## 进程调度

**题目：**

![image-20211225110756087](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225110756.png)

**答案：**

![A9DAF05BFB834FF3577B7BB85CF7A896](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225110714.png)



## 死锁策略

> 避免死锁——银行家算法

**题目：**

![image-20211225111116264](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225111116.png)

**答案：**

![6B5BC30D3529E5AB6AEF33229227271F](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225111553.png)





## 分页存储地址映射

**题目：**

![image-20211225111133159](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225111133.png)

**答案：**

![784B70E3BD7CA5328A87C2D5E81291B6](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225111546.png)



## 页面置换

**题目：**

![image-20211225111145889](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225111146.png)

**答案：**

最佳 (Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。 但由于人们目前无法预知进程在内存下的若千页面中哪个是**未来最长时间内不再被访问的**，因而该算法无法实现。

![C27836475C3A4544C52642FCB7B33B48](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225111244.png)



## 磁盘调度算法

**题目：**

![image-20211225111201428](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225111201.png)

**答案：**

最短寻道时间优先（SSTF）算法 ：**优先选择距当前磁头最近的访问请求进行服务**，

主要考虑寻道优先。 优点：改善了磁盘平均服务时间；缺点：造成某些访问请求长期等待得不到服务。



所谓**电梯调度算法**，顾名思义，请求的处理按照块设备的偏移（一般是扇区号）朝一个方向移动，直到到达最远的对方，然后再按照反方向移动，就像电梯的运行过程一样。

![0019EC6556C0629AB63FE2BD6A06628B](https://typora-pff.oss-cn-hangzhou.aliyuncs.com/20211225111235.png)



